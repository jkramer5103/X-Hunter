<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mr. X Jagd - {{ username }} {% if username == mr_x_username %}(Du bist Mr. X){% endif %}</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">

    <style>
        /* Grundlegende Layout-Styles */
        html, body { height: 100%; margin: 0; padding: 0; font-family: sans-serif; }
        body { display: flex; flex-direction: column; }
        #map-container { flex-grow: 1; position: relative; min-height: 0; }
        #map { height: 100%; width: 100%; cursor: default; }
        #map.decoy-placement-active { cursor: crosshair !important; }
        #header { padding: 8px 15px; background-color: #f0f0f0; border-bottom: 1px solid #ccc; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; flex-wrap: wrap; gap: 10px; }
        #header .user-info span { margin-right: 15px; }
        #header .user-info strong { color: #007bff; }
        #header .game-info { font-weight: bold; }
        #header .game-info .mrx { color: #d9534f; }
        #header a { text-decoration: none; color: #007bff; margin-left: 10px; }
        #timer-info { font-weight: bold; color: #555; background-color: #e9ecef; padding: 5px 10px; border-radius: 4px; }
        .action-bar { display: flex; justify-content: center; align-items: center; gap: 15px; margin-top: 10px; text-align: center; padding: 10px; border-top: 1px solid #ccc; flex-shrink: 0; }
        .action-bar button { padding: 8px 15px; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em; }
        .action-bar button:hover { opacity: 0.9; }
        .action-bar button:disabled { background-color: #aaa !important; cursor: not-allowed; opacity: 0.7; }
        .action-bar label { margin: 0; }
        .action-bar select { margin-left: 5px; padding: 5px; border-radius: 3px; border: 1px solid #ccc; }
        #mrx-actions { background-color: #f8d7da; border-color: #f5c6cb; }
        #mrx-actions button { background-color: #d9534f; }
        #mrx-actions button:hover { background-color: #c9302c; }
        #decoy-button { background-color: #f0ad4e !important; }
        #decoy-button:hover { background-color: #ec971f !important; }
        #decoy-button.placing { background-color: #5bc0de !important; }
        #seeker-actions { background-color: #d9edf7; border-color: #bce8f1; }
        #invisibility-button { background-color: #6c757d; }
        #invisibility-button:hover { background-color: #5a6268; }
        #invisibility-button.active { background-color: #31708f !important; }
        #invisibility-timer-display { margin-left: 15px; font-weight: bold; color: #31708f; display: none; }
        #game-over-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); color: white; display: none; justify-content: center; align-items: center; text-align: center; z-index: 1000; font-size: 1.5em; }
        #game-over-overlay h2 { margin-bottom: 20px; }
        #game-over-overlay button { margin-top: 20px; padding: 10px 20px; font-size: 1em; cursor: pointer; }
        #connection-lost-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); color: #ffc107; display: none; justify-content: center; align-items: center; text-align: center; z-index: 2000; font-size: 1.8em; padding: 20px; box-sizing: border-box; }
        #connection-lost-overlay p { margin: 0; }
        /* Marker Styles */
        .player-marker { background-color: rgba(51, 136, 255, 0.8); border: 2px solid white; border-radius: 50%; box-shadow: 0 0 5px rgba(0,0,0,0.5); width: 15px; height: 15px; }
        .own-player-marker { background-color: rgba(0, 123, 255, 0.9); border: 2px solid white; width: 18px; height: 18px; border-radius: 50%; box-shadow: 0 0 6px rgba(0, 123, 255, 0.7); }
        .mrx-marker { background-color: rgba(217, 83, 79, 0.9); border: 2px solid white; width: 18px; height: 18px; border-radius: 50%; box-shadow: 0 0 8px rgba(255, 0, 0, 0.8); }
        .mrx-realtime-marker { background-color: rgb(81, 221, 0); border: 1px solid white; border-radius: 50%; width: 10px; height: 10px; box-shadow: 0 0 3px rgb(62, 170, 0); }
        .decoy-placement-marker { background-color: rgba(240, 173, 78, 0.7); border: 2px dashed white; border-radius: 50%; width: 20px; height: 20px; }
        .map-popup-button { padding: 5px 10px; margin-top: 8px; font-size: 0.9em; background-color: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer; }
        .map-popup-button:hover { background-color: #5a6268; }
        .leaflet-popup-content { min-width: 130px; text-align: center; }
        /* Chat Styles */
        #chat-toggle-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1001;
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #chat-panel {
            position: fixed;
            bottom: 70px;
            right: 20px;
            width: 300px;
            height: 400px;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            flex-direction: column;
        }
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            border-bottom: 1px solid #eee;
            font-size: 0.9em;
        }
        #chat-messages div {
            margin-bottom: 5px;
            word-wrap: break-word;
        }
        #chat-messages strong {
            color: #007bff;
        }
        #chat-input-area {
            display: flex;
            padding: 10px;
        }
        #chat-input {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 3px 0 0 3px;
        }
        #send-chat-button {
            padding: 8px 12px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 0 3px 3px 0;
            cursor: pointer;
        }
        #send-chat-button:hover {
            background-color: #218838;
        }
    </style>
</head>
<body>

<div id="header">
    <div class="user-info">
        <span>Angemeldet als: <strong>{{ username }}</strong></span>
        <span class="game-info">
            Spiel aktiv! Mr. X: <span class="mrx">{{ mr_x_username }}</span>
            {% if username == mr_x_username %}(Du bist Mr. X){% endif %}
        </span>
    </div>
    <div id="timer-info">
        Nächstes Mr. X Update in: <span id="mrx-timer-display">--:--</span>
    </div>
    <div>
        <a href="{{ url_for('logout') }}">Logout</a>
    </div>
</div>

<div id="map-container">
    <div id="map"></div>
    <div id="game-over-overlay">
        <div>
            <h2 id="game-over-message">Spiel vorbei!</h2>
            <button id="back-to-start-button">Zurück zur Startseite</button>
        </div>
    </div>
    <div id="connection-lost-overlay">
        <div>
            <h2>Verbindung verloren!</h2>
            <p>Versuche erneut zu verbinden...</p>
        </div>
    </div>
</div>

<!-- Aktionsleiste für Mr. X -->
{% if username == mr_x_username %}
<div id="mrx-actions" class="action-bar">
    <button id="decoy-button" {% if mrx_remaining_decoys <= 0 %}disabled{% endif %}>
        Ablenkungsmanöver ({{ mrx_remaining_decoys }} verfügbar)
    </button>
    <div>
        <label for="finder-selection">Ich wurde gefunden von:</label>
        <select id="finder-selection">
            <option value="" disabled selected>-- Spieler auswählen --</option>
            {% for player in current_players_list %}
                <option value="{{ player }}">{{ player }}</option>
            {% endfor %}
        </select>
        <button id="found-button">Gefunden melden!</button>
    </div>
</div>
{% endif %}

<!-- Aktionsleiste für Sucher -->
{% if username != mr_x_username %}
<div id="seeker-actions" class="action-bar">
     <button id="invisibility-button" {% if seeker_remaining_invisibility <= 0 %}disabled{% endif %}>
        Unsichtbarkeit ({{ seeker_remaining_invisibility }} verfügbar)
    </button>
    <div id="invisibility-timer-display">Unsichtbar für: <span>--:--</span></div>
</div>
{% endif %}

<!-- Chat-Elemente (nur für Sucher) -->
{% if username != mr_x_username %}
    <button id="chat-toggle-button">Chat</button>
    <div id="chat-panel">
        <div id="chat-messages">
            <!-- Chat-Nachrichten werden hier eingefügt -->
        </div>
        <div id="chat-input-area">
            <input type="text" id="chat-input" placeholder="Nachricht eingeben...">
            <button id="send-chat-button">Senden</button>
        </div>
    </div>
{% endif %}


<script>
    // --- Globale Variablen ---
    let map;
    let userMarkers = {};
    const currentUsername = "{{ username }}";
    const mrXUsername = "{{ mr_x_username }}";
    let ownMarkerData = null;
    let isMrX = currentUsername === mrXUsername;
    let mrxRealTimeMarker = null;
    // Decoy
    let mrxRemainingDecoys = {{ mrx_remaining_decoys | default(0) }};
    let isPlacingDecoy = false;
    let tempDecoyMarker = null;
    // Timer
    let mrxUpdateIntervalSeconds = 0;
    let mrxLastBroadcastTimestampMs = 0;
    let timerIntervalId = null;
    const timerDisplayElement = document.getElementById('mrx-timer-display');
    // Unsichtbarkeit
    let seekerRemainingInvisibility = {{ seeker_remaining_invisibility | default(0) }};
    let isInvisible = false;
    let invisibilityTimeoutId = null;
    let invisibilityCountdownIntervalId = null;
    const invisibilityTimerElement = document.getElementById('invisibility-timer-display');
    const invisibilityTimerSpan = invisibilityTimerElement ? invisibilityTimerElement.querySelector('span') : null;
    // Animation
    const ANIMATION_DURATION_MS = 1500;
    let animationFrameRequestId = null;
    // Connection Lost
    let connectionLostOverlay = null;
    // Chat
    let chatPanel = null;
    let chatMessagesDiv = null;
    let chatInput = null;
    let sendChatButton = null;
    let chatToggleButton = null;


    // --- Initialisierung ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM geladen. Initialisiere Karte und SocketIO.");
        connectionLostOverlay = document.getElementById('connection-lost-overlay');

        if (isMrX) { updateDecoyButtonState(); }
        else {
            updateInvisibilityButtonState();
            // Chat-Elemente initialisieren (nur für Sucher)
            chatPanel = document.getElementById('chat-panel');
            chatMessagesDiv = document.getElementById('chat-messages');
            chatInput = document.getElementById('chat-input');
            sendChatButton = document.getElementById('send-chat-button');
            chatToggleButton = document.getElementById('chat-toggle-button');
            if (chatToggleButton) chatToggleButton.addEventListener('click', toggleChatPanel);
            if (sendChatButton) sendChatButton.addEventListener('click', sendChatMessage);
            if (chatInput) chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') sendChatMessage(); });
        }
        initializeMap();
        initializeSocketIO();
        startLocationWatch();

        const foundButton = document.getElementById('found-button');
        if (foundButton) foundButton.addEventListener('click', reportFound);
        const decoyButton = document.getElementById('decoy-button');
        if (decoyButton) decoyButton.addEventListener('click', toggleDecoyPlacement);
        const invisibilityButton = document.getElementById('invisibility-button');
        if (invisibilityButton) invisibilityButton.addEventListener('click', activateInvisibility);

        document.getElementById('back-to-start-button').addEventListener('click', () => {
            window.location.href = "{{ url_for('index') }}";
        });
    });

    // --- Karteninitialisierung ---
    function initializeMap() {
        map = L.map('map').setView([53.5511, 9.9937], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);
        console.log("Karte initialisiert.");
        map.on('click', handleMapClickForDecoy);
    }

    // --- Socket.IO Initialisierung & Event Handling ---
    function initializeSocketIO() {
        const socket = io();
        window.socket = socket;

        socket.on('connect', () => {
            console.log('Verbunden mit WebSocket-Server (Karte).');
            if (connectionLostOverlay) { connectionLostOverlay.style.display = 'none'; }
        });
        socket.on('disconnect', (reason) => {
            console.warn('WebSocket-Verbindung getrennt:', reason);
            stopTimer(); stopInvisibilityCountdown();
            if (connectionLostOverlay) { connectionLostOverlay.style.display = 'flex'; }
        });
        socket.on('connect_error', (err) => {
            console.error('WebSocket Verbindungsfehler:', err);
            if (connectionLostOverlay) { connectionLostOverlay.style.display = 'flex'; }
        });

        socket.on('game_update', (data) => {
            console.log('Spielstatus-Update erhalten:', data);
            Object.keys(userMarkers).forEach(username => removeMarker(username));
            if (ownMarkerData) { removeMarker(currentUsername); }
            if (mrxRealTimeMarker) { map.removeLayer(mrxRealTimeMarker); mrxRealTimeMarker = null; }

            if (data.locations) {
                for (const username in data.locations) {
                    const locData = data.locations[username];
                    if (locData && locData.lat !== undefined && locData.lon !== undefined) {
                        if (username === currentUsername) { updateOwnMarker(locData.lat, locData.lon, true); }
                        else { updateMarker(username, locData.lat, locData.lon, true); }
                    } else { console.warn(`Unvollständige Standortdaten für ${username} in game_update:`, locData); }
                }
            } else { console.warn("game_update ohne Standortdaten empfangen."); }

            updateFinderList(data.players || []);
            if (isMrX && data.mrx_remaining_decoys !== null && data.mrx_remaining_decoys !== undefined) {
                mrxRemainingDecoys = data.mrx_remaining_decoys; updateDecoyButtonState();
            }
            if (!isMrX && data.seeker_remaining_invisibility !== null && data.seeker_remaining_invisibility !== undefined) {
                seekerRemainingInvisibility = data.seeker_remaining_invisibility; updateInvisibilityButtonState();
            }
            if (data.mrx_update_interval_minutes && data.mrx_last_broadcast_time !== undefined) {
                mrxUpdateIntervalSeconds = data.mrx_update_interval_minutes * 60;
                mrxLastBroadcastTimestampMs = data.mrx_last_broadcast_time * 1000;
                console.log(`Timer init: Interval=${mrxUpdateIntervalSeconds}s, LastBroadcast=${new Date(mrxLastBroadcastTimestampMs).toLocaleTimeString()}`);
                startTimer();
            } else { console.warn("Timer-Daten in game_update fehlen."); timerDisplayElement.textContent = "N/A"; }
        });

        socket.on('location_update', (data) => {
            if (data.previous_was_decoy) { showTemporaryMessage(`Achtung! Der vorherige Standort von Mr. X (${mrXUsername}) war ein Ablenkungsmanöver!`, "warning"); }
            if (data.lat !== undefined && data.lon !== undefined) {
                if (data.username === currentUsername) { updateOwnMarker(data.lat, data.lon); }
                else { updateMarker(data.username, data.lat, data.lon); }
            } else { console.warn(`Unvollständige Standortdaten in location_update für ${data.username}:`, data); }
        });

        socket.on('player_joined', (data) => {
            console.log(`Spieler beigetreten: ${data.username}`);
            addPlayerToFinderList(data.username);
            showTemporaryMessage(`${data.username} ist dem Spiel beigetreten.`, "info");
        });

        socket.on('player_left', (data) => {
            console.log(`Spieler gegangen: ${data.username}`);
            removeMarker(data.username);
            removePlayerFromFinderList(data.username);
            showTemporaryMessage(`${data.username} hat das Spiel verlassen.`, "warning");
        });

        socket.on('decoy_set_confirmation', (data) => {
            console.log("Decoy wurde vom Server bestätigt:", data);
            showTemporaryMessage("Ablenkungsmanöver gesetzt! Der falsche Standort wird beim nächsten Update gesendet.", "success");
            if (data.remaining_decoys !== undefined) { mrxRemainingDecoys = data.remaining_decoys; }
            else { mrxRemainingDecoys = 0; }
            updateDecoyButtonState();
            if (tempDecoyMarker) { map.removeLayer(tempDecoyMarker); tempDecoyMarker = null; }
        });

        socket.on('mrx_update_timer', (data) => {
            if (data.last_broadcast_time !== undefined) {
                mrxLastBroadcastTimestampMs = data.last_broadcast_time * 1000;
                console.log(`Timer reset: LastBroadcast=${new Date(mrxLastBroadcastTimestampMs).toLocaleTimeString()}`);
                updateTimerDisplay();
            } else { console.warn("mrx_update_timer Event ohne Zeitstempel empfangen."); }
        });

        socket.on('invisibility_activated', (data) => {
            if (!isMrX) {
                console.log("Invisibility activated:", data);
                seekerRemainingInvisibility = data.remaining_uses;
                isInvisible = true;
                updateInvisibilityButtonState();
                showTemporaryMessage(`Du bist jetzt für ${data.duration} Sekunden unsichtbar!`, "info");
                startInvisibilityCountdown(data.duration);
            }
        });
        socket.on('invisibility_ended', () => {
             if (!isMrX) {
                console.log("Invisibility ended.");
                isInvisible = false;
                stopInvisibilityCountdown();
                updateInvisibilityButtonState();
                showTemporaryMessage("Du bist wieder sichtbar!", "info");
            }
        });
        socket.on('player_invisible', (data) => {
            if (data.username !== currentUsername) {
                console.log(`Player ${data.username} is now invisible.`);
                removeMarker(data.username);
                showTemporaryMessage(`${data.username} ist unsichtbar geworden!`, 'warning');
            }
        });
        socket.on('player_visible', (data) => {
             if (data.username !== currentUsername) {
                console.log(`Player ${data.username} is visible again.`);
                if (data.lat !== undefined && data.lon !== undefined && data.lat !== null) {
                    updateMarker(data.username, data.lat, data.lon, true);
                    showTemporaryMessage(`${data.username} ist wieder sichtbar!`, 'info');
                } else {
                     console.warn(`Player ${data.username} became visible but location is missing.`);
                     showTemporaryMessage(`${data.username} ist wieder sichtbar!`, 'info');
                }
            }
        });

        socket.on('new_chat_message', (data) => {
            if (!isMrX && chatMessagesDiv) {
                appendChatMessage(data.username, data.message);
            }
        });

        socket.on('game_over', (data) => {
            console.log("Spiel vorbei!", data);
            document.getElementById('game-over-message').innerText = data.message;
            document.getElementById('game-over-overlay').style.display = 'flex';
            if (locationWatchId) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; }
            if (isPlacingDecoy) { exitDecoyPlacementMode(); }
            stopTimer();
            stopInvisibilityCountdown();
            if (mrxRealTimeMarker) { map.removeLayer(mrxRealTimeMarker); mrxRealTimeMarker = null; }
            cancelAnimationFrame(animationFrameRequestId); animationFrameRequestId = null;
            const mrxActions = document.getElementById('mrx-actions');
            if (mrxActions) mrxActions.querySelectorAll('button, select').forEach(el => el.disabled = true);
            const seekerActions = document.getElementById('seeker-actions');
            if (seekerActions) seekerActions.querySelectorAll('button').forEach(el => el.disabled = true);
            // Chat auch schließen/deaktivieren
            if (chatPanel) chatPanel.style.display = 'none';
            if (chatToggleButton) chatToggleButton.disabled = true;
        });

        socket.on('redirect', (data) => {
            console.log('Redirect empfangen:', data.url);
            showTemporaryMessage("Kein Spiel aktiv. Leite zur Startseite weiter...", "info");
            setTimeout(() => { window.location.href = data.url; }, 2000);
        });

        socket.on('error_message', (data) => {
             console.error("Fehler vom Server:", data.message);
             alert(`Fehler: ${data.message}`);
         });
    }

    // --- Geolocation ---
    let locationWatchId = null;
    function startLocationWatch() {
        if (!navigator.geolocation) { console.error("Geolocation wird nicht unterstützt."); alert("Dein Browser unterstützt Geolocation nicht."); return; }
        console.log("Starte Geolocation Watch...");
        const options = { enableHighAccuracy: true, timeout: 15000, maximumAge: 5000 };
        locationWatchId = navigator.geolocation.watchPosition(
            (position) => {
                const lat = position.coords.latitude; const lon = position.coords.longitude;
                if (isMrX) { updateMrXRealTimeMarker(lat, lon); }
                else { updateOwnMarker(lat, lon); }
                if (window.socket && window.socket.connected) { window.socket.emit('update_location', { lat: lat, lon: lon }); }
                else { console.warn("Socket nicht verbunden. Position konnte nicht gesendet werden."); }
            },
            (error) => { console.error("Geolocation Fehler: ", error); }, options
        );
    }

    // --- Marker-Management ---
    function createMarkerIcon(username) {
        const isOwn = username === currentUsername;
        const isUserMrX = username === mrXUsername;
        let className = 'player-marker';
        let iconSize = [15, 15];
        if (isOwn) { className = 'player-marker own-player-marker'; iconSize = [18, 18]; }
        if (isUserMrX) { className = 'player-marker mrx-marker'; iconSize = [18, 18]; }
        return L.divIcon({ className: className, iconSize: iconSize, iconAnchor: [iconSize[0] / 2, iconSize[1] / 2], popupAnchor: [0, -iconSize[1] / 2] });
    }

    function createPopupContent(username, lat, lon) {
        const mapsUrl = `https://www.google.com/maps?q=${lat},${lon}`;
        let title;
        if (username === currentUsername && isMrX) {
             title = `<strong>Deine gesendete Position</strong><br><span style="font-size:0.9em;">(Was Sucher sehen)</span>`;
        } else if (username === currentUsername) {
             title = `<strong>Das bin ich (${currentUsername})</strong>`;
        } else {
             title = `<strong>${username}</strong>`;
             if (username === mrXUsername) title += ' <span style="color:red;">(Mr. X)</span>';
        }
        const buttonHtml = `<button class="map-popup-button" onclick="window.open('${mapsUrl}', '_blank')">In Google Maps öffnen</button>`;
        return `${title}<br>${buttonHtml}`;
    }

    function updateOwnMarker(lat, lon, setImmediately = false) {
        const targetPos = L.latLng(lat, lon);
        const icon = createMarkerIcon(currentUsername);
        const popupContent = createPopupContent(currentUsername, lat, lon);
        if (!ownMarkerData) {
            const marker = L.marker(targetPos, { icon: icon, zIndexOffset: 1000 }).addTo(map);
            marker.bindPopup(popupContent);
            ownMarkerData = { marker: marker, animation: null };
        } else {
            ownMarkerData.marker.setIcon(icon);
            ownMarkerData.marker.setPopupContent(popupContent);
            if (setImmediately) {
                 if (ownMarkerData.animation) { cancelAnimationFrame(ownMarkerData.animation.rafId); ownMarkerData.animation = null; }
                 ownMarkerData.marker.setLatLng(targetPos);
            } else { startMarkerAnimation(currentUsername, ownMarkerData, targetPos); }
        }
    }

    function updateMrXRealTimeMarker(lat, lon) {
        if (!isMrX) return;
        const latLng = L.latLng(lat, lon);
        const icon = L.divIcon({ className: 'mrx-realtime-marker', iconSize: [10, 10], iconAnchor: [5, 5] });
        if (mrxRealTimeMarker) {
            mrxRealTimeMarker.setLatLng(latLng);
        } else {
            mrxRealTimeMarker = L.marker(latLng, { icon: icon, zIndexOffset: 1100, interactive: false }).addTo(map);
        }
    }

    function updateMarker(username, lat, lon, setImmediately = false) {
        if (username === currentUsername) { updateOwnMarker(lat, lon, setImmediately); return; }
        const targetPos = L.latLng(lat, lon);
        const icon = createMarkerIcon(username);
        const popupContent = createPopupContent(username, lat, lon);
        if (!userMarkers[username]) {
            const zIndex = (username === mrXUsername) ? 900 : 500;
            const marker = L.marker(targetPos, { icon: icon, zIndexOffset: zIndex }).addTo(map);
            marker.bindPopup(popupContent);
            userMarkers[username] = { marker: marker, animation: null };
            console.log(`Marker für ${username} erstellt.`);
        } else {
            userMarkers[username].marker.setIcon(icon);
            userMarkers[username].marker.setPopupContent(popupContent);
             if (setImmediately) {
                 if (userMarkers[username].animation) { cancelAnimationFrame(userMarkers[username].animation.rafId); userMarkers[username].animation = null; }
                 userMarkers[username].marker.setLatLng(targetPos);
            } else { startMarkerAnimation(username, userMarkers[username], targetPos); }
        }
    }

    function removeMarker(username) {
        const markerData = (username === currentUsername) ? ownMarkerData : userMarkers[username];
        if (markerData) {
            if (markerData.animation) { cancelAnimationFrame(markerData.animation.rafId); markerData.animation = null; }
            map.removeLayer(markerData.marker);
            console.log(`Marker für ${username} entfernt.`);
        }
        if (username === currentUsername) { ownMarkerData = null; }
        else { delete userMarkers[username]; }
    }

    // --- Animationslogik ---
    function startMarkerAnimation(username, markerData, targetPos) {
        const marker = markerData.marker;
        const startPos = marker.getLatLng();
        const startTime = Date.now();
        if (markerData.animation) { cancelAnimationFrame(markerData.animation.rafId); }
        markerData.animation = { startPos: startPos, targetPos: targetPos, startTime: startTime, duration: ANIMATION_DURATION_MS, rafId: null };
        if (!animationFrameRequestId) { animationFrameRequestId = requestAnimationFrame(animateMarkers); }
    }

    function animateMarkers(timestamp) {
        let stillAnimating = false;
        const now = Date.now();
        if (ownMarkerData && ownMarkerData.animation) {
            if (animateSingleMarker(ownMarkerData, now)) { stillAnimating = true; }
            else { ownMarkerData.animation = null; }
        }
        for (const username in userMarkers) {
            const markerData = userMarkers[username];
            if (markerData.animation) {
                if (animateSingleMarker(markerData, now)) { stillAnimating = true; }
                else { markerData.animation = null; }
            }
        }
        if (stillAnimating) { animationFrameRequestId = requestAnimationFrame(animateMarkers); }
        else { animationFrameRequestId = null; console.log("Animation loop stopped."); }
    }

    function animateSingleMarker(markerData, now) {
        const anim = markerData.animation;
        const elapsedTime = now - anim.startTime;
        const fraction = Math.min(1, elapsedTime / anim.duration);
        const lat = anim.startPos.lat + (anim.targetPos.lat - anim.startPos.lat) * fraction;
        const lng = anim.startPos.lng + (anim.targetPos.lng - anim.startPos.lng) * fraction;
        markerData.marker.setLatLng([lat, lng]);
        return fraction < 1;
    }

    // --- Mr. X Aktionen ---
    function reportFound() {
        const finderSelect = document.getElementById('finder-selection');
        const selectedFinder = finderSelect ? finderSelect.value : null;
        if (!selectedFinder) { alert("Bitte wähle aus, wer dich gefunden hat."); return; }
        console.log(`Melde: Gefunden von ${selectedFinder}`);
        if (window.socket && window.socket.connected) {
            window.socket.emit('mr_x_found', { finder: selectedFinder });
            document.getElementById('found-button').disabled = true;
            finderSelect.disabled = true;
             const decoyButton = document.getElementById('decoy-button');
             if (decoyButton) decoyButton.disabled = true;
        } else { alert("Keine Verbindung zum Server. Konnte Fund nicht melden."); }
    }

    function toggleDecoyPlacement() {
        if (!isMrX || mrxRemainingDecoys <= 0) return;
        isPlacingDecoy = !isPlacingDecoy;
        if (isPlacingDecoy) { enterDecoyPlacementMode(); }
        else { exitDecoyPlacementMode(); }
    }

    function enterDecoyPlacementMode() {
        console.log("Entering decoy placement mode.");
        isPlacingDecoy = true;
        document.getElementById('map').classList.add('decoy-placement-active');
        const decoyButton = document.getElementById('decoy-button');
        decoyButton.textContent = "Klicke auf die Karte für den falschen Standort...";
        decoyButton.classList.add('placing');
        showTemporaryMessage("Klicke auf die Karte, um den falschen Standort für das Ablenkungsmanöver zu wählen.", "info");
    }

    function exitDecoyPlacementMode() {
        console.log("Exiting decoy placement mode.");
        isPlacingDecoy = false;
        document.getElementById('map').classList.remove('decoy-placement-active');
        updateDecoyButtonState();
         if (tempDecoyMarker) { map.removeLayer(tempDecoyMarker); tempDecoyMarker = null; }
    }

    function handleMapClickForDecoy(e) {
        if (!isPlacingDecoy || !isMrX) return;
        const lat = e.latlng.lat;
        const lon = e.latlng.lng;
        console.log(`Decoy location selected: Lat=${lat}, Lon=${lon}`);
        if (tempDecoyMarker) map.removeLayer(tempDecoyMarker);
        tempDecoyMarker = L.marker([lat, lon], { icon: L.divIcon({ className: 'decoy-placement-marker', iconSize: [20, 20], iconAnchor: [10, 10] }) }).addTo(map);
        tempDecoyMarker.bindPopup("Falscher Standort hier?").openPopup();
        if (window.socket && window.socket.connected) {
            window.socket.emit('set_decoy_location', { lat: lat, lon: lon });
        } else { alert("Keine Verbindung zum Server. Ablenkungsmanöver konnte nicht gesetzt werden."); }
        exitDecoyPlacementMode();
    }

    function updateDecoyButtonState() {
        const decoyButton = document.getElementById('decoy-button');
        if (!decoyButton) return;
        decoyButton.classList.remove('placing');
        if (mrxRemainingDecoys > 0) {
            decoyButton.disabled = false;
            decoyButton.textContent = `Ablenkungsmanöver (${mrxRemainingDecoys} verfügbar)`;
        } else {
            decoyButton.disabled = true;
            decoyButton.textContent = "Keine Ablenkungsmanöver mehr";
        }
    }

    // --- Sucher Aktionen ---
    function activateInvisibility() {
        if (isMrX || seekerRemainingInvisibility <= 0 || isInvisible) { return; }
        console.log("Requesting invisibility...");
        if (window.socket && window.socket.connected) { window.socket.emit('activate_invisibility'); }
        else { alert("Keine Verbindung zum Server. Unsichtbarkeit konnte nicht aktiviert werden."); }
    }

    function updateInvisibilityButtonState() {
        const invisButton = document.getElementById('invisibility-button');
        if (!invisButton) return;
        invisButton.classList.remove('active');
        if (isInvisible) {
            invisButton.disabled = true;
            invisButton.textContent = "Unsichtbar aktiv";
            invisButton.classList.add('active');
        } else if (seekerRemainingInvisibility > 0) {
            invisButton.disabled = false;
            invisButton.textContent = `Unsichtbarkeit (${seekerRemainingInvisibility} verfügbar)`;
        } else {
            invisButton.disabled = true;
            invisButton.textContent = "Keine Unsichtbarkeit mehr";
        }
    }

    // --- Chat Funktionen ---
    function toggleChatPanel() {
        if (chatPanel) {
            const isHidden = chatPanel.style.display === 'none' || chatPanel.style.display === '';
            chatPanel.style.display = isHidden ? 'flex' : 'none';
            if (isHidden) { chatInput.focus(); scrollToChatBottom(); }
        }
    }

    function sendChatMessage() {
        if (!chatInput || !window.socket || !window.socket.connected) return;
        const message = chatInput.value.trim();
        if (message) {
            window.socket.emit('send_chat_message', { message: message });
            chatInput.value = '';
        }
    }

    function appendChatMessage(username, message) {
        if (!chatMessagesDiv) return;
        const messageElement = document.createElement('div');
        const sanitizedMessage = message.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        messageElement.innerHTML = `<strong>${username}:</strong> ${sanitizedMessage}`;
        chatMessagesDiv.appendChild(messageElement);
        scrollToChatBottom();
    }

    function scrollToChatBottom() {
         if (chatMessagesDiv) { chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight; }
    }

    // --- Hilfsfunktionen für Finder-Liste ---
    function updateFinderList(playerUsernames) {
         const finderSelect = document.getElementById('finder-selection');
         if (!finderSelect) return;
         console.log("Updating finder list with players:", playerUsernames);
         const currentSelection = finderSelect.value;
         while (finderSelect.options.length > 1) { finderSelect.remove(1); }
         playerUsernames.forEach(username => {
             if (username !== currentUsername) {
                 const option = document.createElement('option');
                 option.value = username;
                 option.textContent = username;
                 finderSelect.appendChild(option);
             }
         });
         finderSelect.value = currentSelection;
     }

     function addPlayerToFinderList(username) {
         const finderSelect = document.getElementById('finder-selection');
         if (!finderSelect || username === currentUsername) return;
         console.log("Adding player to finder list:", username);
         let exists = false;
         for (let i = 0; i < finderSelect.options.length; i++) { if (finderSelect.options[i].value === username) { exists = true; break; } }
         if (!exists) {
             const option = document.createElement('option');
             option.value = username;
             option.textContent = username;
             finderSelect.appendChild(option);
         }
     }

     function removePlayerFromFinderList(username) {
         const finderSelect = document.getElementById('finder-selection');
         if (!finderSelect) return;
         console.log("Removing player from finder list:", username);
         for (let i = 0; i < finderSelect.options.length; i++) { if (finderSelect.options[i].value === username) { finderSelect.remove(i); break; } }
     }

     // --- Temporäre Nachrichten anzeigen ---
     function showTemporaryMessage(message, type = "info") {
         const messageDiv = document.createElement('div');
         messageDiv.textContent = message;
         messageDiv.style.position = 'absolute';
         messageDiv.style.top = '10px';
         messageDiv.style.left = '50%';
         messageDiv.style.transform = 'translateX(-50%)';
         messageDiv.style.padding = '10px 20px';
         messageDiv.style.borderRadius = '5px';
         messageDiv.style.zIndex = '1500';
         messageDiv.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
         messageDiv.style.opacity = '1';
         messageDiv.style.transition = 'opacity 0.5s ease-out';
         if (type === "error") { messageDiv.style.backgroundColor = '#f8d7da'; messageDiv.style.color = '#721c24'; messageDiv.style.border = '1px solid #f5c6cb'; }
         else if (type === "warning") { messageDiv.style.backgroundColor = '#fcf8e3'; messageDiv.style.color = '#8a6d3b'; messageDiv.style.border = '1px solid #faebcc'; }
         else { messageDiv.style.backgroundColor = '#d9edf7'; messageDiv.style.color = '#31708f'; messageDiv.style.border = '1px solid #bce8f1'; }
         document.getElementById('map-container').appendChild(messageDiv);
         setTimeout(() => {
             messageDiv.style.opacity = '0';
             setTimeout(() => { messageDiv.remove(); }, 500);
         }, 3500);
     }

    // --- Timer Funktionen (Mr. X Update) ---
    function startTimer() {
        stopTimer();
        if (mrxUpdateIntervalSeconds > 0) {
            console.log("Starting Mr. X update timer.");
            updateTimerDisplay();
            timerIntervalId = setInterval(updateTimerDisplay, 1000);
        } else {
             timerDisplayElement.textContent = "N/A";
             console.log("Timer nicht gestartet (Intervall 0 oder ungültig).");
        }
    }

    function stopTimer() {
        if (timerIntervalId) {
            console.log("Stopping Mr. X update timer.");
            clearInterval(timerIntervalId);
            timerIntervalId = null;
            timerDisplayElement.textContent = "--:--";
        }
    }

    function updateTimerDisplay() {
        if (mrxUpdateIntervalSeconds <= 0 || mrxLastBroadcastTimestampMs <= 0) {
             timerDisplayElement.textContent = "Warte...";
             return;
        }
        const nowMs = Date.now();
        const nextBroadcastTimeMs = mrxLastBroadcastTimestampMs + (mrxUpdateIntervalSeconds * 1000);
        const remainingSeconds = Math.max(0, Math.round((nextBroadcastTimeMs - nowMs) / 1000));
        timerDisplayElement.textContent = formatTime(remainingSeconds);
    }

    function formatTime(totalSeconds) {
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        const paddedMinutes = String(minutes).padStart(2, '0');
        const paddedSeconds = String(seconds).padStart(2, '0');
        return `${paddedMinutes}:${paddedSeconds}`;
    }

    // --- Timer Funktionen (Unsichtbarkeit) ---
    function startInvisibilityCountdown(durationSeconds) {
        stopInvisibilityCountdown();
        if (!invisibilityTimerElement || !invisibilityTimerSpan) return;
        let remaining = durationSeconds;
        const endTimeMs = Date.now() + (durationSeconds * 1000);
        function updateDisplay() {
            const nowMs = Date.now();
            remaining = Math.max(0, Math.round((endTimeMs - nowMs) / 1000));
            invisibilityTimerSpan.textContent = formatTime(remaining);
            if (remaining <= 0) { stopInvisibilityCountdown(); }
        }
        invisibilityTimerElement.style.display = 'inline';
        updateDisplay();
        invisibilityCountdownIntervalId = setInterval(updateDisplay, 1000);
    }

    function stopInvisibilityCountdown() {
        if (invisibilityCountdownIntervalId) {
            clearInterval(invisibilityCountdownIntervalId);
            invisibilityCountdownIntervalId = null;
        }
        if (invisibilityTimerElement) {
            invisibilityTimerElement.style.display = 'none';
        }
    }

</script>

</body>
</html>
