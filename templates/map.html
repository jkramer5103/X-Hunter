<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mr. X Jagd - {{ username }} {% if username == mr_x_username %}(Du bist Mr. X){% endif %}</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">

    <style>
        /* Grundlegende Layout-Styles */
        html, body { height: 100%; margin: 0; padding: 0; font-family: sans-serif; }
        body { display: flex; flex-direction: column; }
        #map-container { flex-grow: 1; position: relative; min-height: 0; }
        #map { height: 100%; width: 100%; cursor: default; }
        #map.decoy-placement-active { cursor: crosshair !important; }
        #header { padding: 8px 15px; background-color: #f0f0f0; border-bottom: 1px solid #ccc; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
        #header .user-info span { margin-right: 15px; }
        #header .user-info strong { color: #007bff; }
        #header .game-info { font-weight: bold; }
        #header .game-info .mrx { color: #d9534f; }
        #header a { text-decoration: none; color: #007bff; margin-left: 10px; }
        #mrx-actions { display: flex; justify-content: center; align-items: center; gap: 15px; margin-top: 10px; text-align: center; padding: 10px; background-color: #f8d7da; border-top: 1px solid #f5c6cb; flex-shrink: 0; }
        #mrx-actions button { padding: 8px 15px; background-color: #d9534f; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em; }
        #mrx-actions button:hover { background-color: #c9302c; }
        #mrx-actions button:disabled { background-color: #aaa; cursor: not-allowed; }
        #mrx-actions label { margin: 0; }
        #finder-selection { margin-left: 5px; padding: 5px; border-radius: 3px; border: 1px solid #ccc; }
        #decoy-button { background-color: #f0ad4e; }
        #decoy-button:hover { background-color: #ec971f; }
        #decoy-button.placing { background-color: #5bc0de; }

        /* Game Over Overlay */
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 1000;
            font-size: 1.5em;
        }
         #game-over-overlay h2 {
             margin-bottom: 20px;
        }
        #game-over-overlay button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
        }

        /* Styles für DivIcon Marker */
        .player-marker {
            background-color: rgba(51, 136, 255, 0.8);
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            width: 15px;
            height: 15px;
        }
        .own-player-marker {
            background-color: rgba(0, 123, 255, 0.9);
            border: 2px solid white;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(0, 123, 255, 0.7);
        }
        .mrx-marker {
            background-color: rgba(217, 83, 79, 0.9);
            border: 2px solid white;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.8);
        }
        .decoy-placement-marker {
            background-color: rgba(240, 173, 78, 0.7);
            border: 2px dashed white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
        }
        /* Leere CSS-Regeln wurden entfernt oder hatten bereits Inhalt */

    </style>
</head>
<body>

<div id="header">
    <div class="user-info">
        <span>Angemeldet als: <strong>{{ username }}</strong></span>
        <span class="game-info">
            Spiel aktiv! Mr. X: <span class="mrx">{{ mr_x_username }}</span>
            {% if username == mr_x_username %}(Du bist Mr. X){% endif %}
        </span>
    </div>
    <div>
        <a href="{{ url_for('logout') }}">Logout</a>
    </div>
</div>

<div id="map-container">
    <div id="map"></div>
    <div id="game-over-overlay">
        <div>
            <h2 id="game-over-message">Spiel vorbei!</h2>
            <button id="back-to-start-button">Zurück zur Startseite</button>
        </div>
    </div>
</div>

{% if username == mr_x_username %}
<div id="mrx-actions">
    <button id="decoy-button" {% if not mrx_decoy_available %}disabled{% endif %}>
        {% if mrx_decoy_available %}Ablenkungsmanöver (1 verfügbar){% else %}Ablenkungsmanöver benutzt{% endif %}
    </button>
    <div>
        <label for="finder-selection">Ich wurde gefunden von:</label>
        <select id="finder-selection">
            <option value="" disabled selected>-- Spieler auswählen --</option>
            {% for player in current_players_list %}
                <option value="{{ player }}">{{ player }}</option>
            {% endfor %}
        </select>
        <button id="found-button">Gefunden melden!</button>
    </div>
</div>
{% endif %}


<script>
    // --- Globale Variablen ---
    let map;
    let userMarkers = {};
    const currentUsername = "{{ username }}";
    const mrXUsername = "{{ mr_x_username }}";
    let ownMarker = null;
    let isMrX = currentUsername === mrXUsername;
    // KORREKTUR: Wert als String übergeben und in JS parsen
    let mrxDecoyAvailable = "{{ mrx_decoy_available }}" === "True"; // Wandelt Python True -> "True" -> JS true
    let isPlacingDecoy = false;
    let tempDecoyMarker = null;

    // --- Initialisierung ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM geladen. Initialisiere Karte und SocketIO (mit Decoy).");
        // Initialen Status des Decoy-Buttons setzen (falls Mr. X)
        if (isMrX) {
            updateDecoyButtonState();
        }
        initializeMap();
        initializeSocketIO();
        startLocationWatch();

        const foundButton = document.getElementById('found-button');
        if (foundButton) foundButton.addEventListener('click', reportFound);
        const decoyButton = document.getElementById('decoy-button');
        if (decoyButton) decoyButton.addEventListener('click', toggleDecoyPlacement);

        document.getElementById('back-to-start-button').addEventListener('click', () => {
            window.location.href = "{{ url_for('index') }}";
        });
    });

    // --- Karteninitialisierung ---
    function initializeMap() {
        map = L.map('map').setView([53.5511, 9.9937], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);
        console.log("Karte initialisiert.");
        map.on('click', handleMapClickForDecoy);
    }

    // --- Socket.IO Initialisierung & Event Handling ---
    function initializeSocketIO() {
        const socket = io();
        window.socket = socket;

        socket.on('connect', () => console.log('Verbunden mit WebSocket-Server (Karte).'));
        socket.on('disconnect', (reason) => console.warn('WebSocket-Verbindung getrennt:', reason));
        socket.on('connect_error', (err) => console.error('WebSocket Verbindungsfehler:', err));

        socket.on('game_update', (data) => {
            console.log('Spielstatus-Update erhalten:', data);
            Object.keys(userMarkers).forEach(username => removeMarker(username));
            if (ownMarker) { map.removeLayer(ownMarker); ownMarker = null; }

            // Robustheit: Prüfen ob locations vorhanden sind
            if (data.locations) {
                for (const username in data.locations) {
                    const locData = data.locations[username];
                    // Robustheit: Prüfen ob locData und Koordinaten vorhanden sind
                    if (locData && locData.lat !== undefined && locData.lon !== undefined) {
                        if (username === currentUsername) {
                            updateOwnMarker(locData.lat, locData.lon);
                        } else {
                            updateMarker(username, locData.lat, locData.lon);
                        }
                    } else {
                         console.warn(`Unvollständige Standortdaten für ${username} in game_update:`, locData);
                    }
                }
            } else {
                console.warn("game_update ohne Standortdaten empfangen.");
            }

            // Robustheit: Standardwert für players setzen
            updateFinderList(data.players || []);

            // Update Decoy Button Status bei Reconnect
            if (isMrX && data.mrx_decoy_available !== null && data.mrx_decoy_available !== undefined) {
                mrxDecoyAvailable = data.mrx_decoy_available;
                updateDecoyButtonState();
            }
        });

        socket.on('location_update', (data) => {
            if (data.previous_was_decoy) {
                showTemporaryMessage(`Achtung! Der vorherige Standort von Mr. X (${mrXUsername}) war ein Ablenkungsmanöver!`, "warning");
            }
            // Robustheit: Prüfen ob Koordinaten vorhanden sind
            if (data.lat !== undefined && data.lon !== undefined) {
                if (data.username === currentUsername) {
                    updateOwnMarker(data.lat, data.lon);
                } else {
                    updateMarker(data.username, data.lat, data.lon);
                }
            } else {
                 console.warn(`Unvollständige Standortdaten in location_update für ${data.username}:`, data);
            }
        });

        socket.on('player_joined', (data) => {
            console.log(`Spieler beigetreten: ${data.username}`);
            addPlayerToFinderList(data.username);
            showTemporaryMessage(`${data.username} ist dem Spiel beigetreten.`, "info");
        });

        socket.on('player_left', (data) => {
            console.log(`Spieler gegangen: ${data.username}`);
            removeMarker(data.username);
            removePlayerFromFinderList(data.username);
            showTemporaryMessage(`${data.username} hat das Spiel verlassen.`, "warning");
        });

        socket.on('decoy_set_confirmation', (data) => {
            console.log("Decoy wurde vom Server bestätigt:", data);
            showTemporaryMessage("Ablenkungsmanöver gesetzt! Der falsche Standort wird beim nächsten Update gesendet.", "success");
            mrxDecoyAvailable = false;
            updateDecoyButtonState();
            if (tempDecoyMarker) {
                map.removeLayer(tempDecoyMarker);
                tempDecoyMarker = null;
            }
        });

        socket.on('game_over', (data) => {
            console.log("Spiel vorbei!", data);
            document.getElementById('game-over-message').innerText = data.message;
            document.getElementById('game-over-overlay').style.display = 'flex';
            if (locationWatchId) {
                navigator.geolocation.clearWatch(locationWatchId);
                locationWatchId = null;
            }
            if (isPlacingDecoy) {
                exitDecoyPlacementMode();
            }
        });

        socket.on('redirect', (data) => {
            console.log('Redirect empfangen:', data.url);
            showTemporaryMessage("Kein Spiel aktiv. Leite zur Startseite weiter...", "info");
            setTimeout(() => {
                 window.location.href = data.url;
            }, 2000);
        });

        socket.on('error_message', (data) => {
             console.error("Fehler vom Server:", data.message);
             alert(`Fehler: ${data.message}`);
         });
    }

    // --- Geolocation ---
    let locationWatchId = null;
    function startLocationWatch() {
        if (!navigator.geolocation) {
            console.error("Geolocation wird nicht unterstützt.");
            alert("Dein Browser unterstützt Geolocation nicht.");
            return;
        }
        console.log("Starte Geolocation Watch...");
        const options = { enableHighAccuracy: true, timeout: 15000, maximumAge: 5000 };

        locationWatchId = navigator.geolocation.watchPosition(
            (position) => {
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                updateOwnMarker(lat, lon);
                if (window.socket && window.socket.connected) {
                    window.socket.emit('update_location', { lat: lat, lon: lon });
                } else {
                    console.warn("Socket nicht verbunden. Position konnte nicht gesendet werden.");
                }
            },
            (error) => {
                console.error("Geolocation Fehler: ", error);
            },
            options
        );
    }

    // --- Marker-Management ---
    function createMarkerIcon(username) {
        const isOwn = username === currentUsername;
        const isUserMrX = username === mrXUsername;
        let className = 'player-marker';
        let iconSize = [15, 15];

        if (isOwn) {
            className = 'player-marker own-player-marker';
            iconSize = [18, 18];
        }
        if (isUserMrX) {
             className = 'player-marker mrx-marker';
             iconSize = [18, 18];
        }

        return L.divIcon({
            className: className,
            iconSize: iconSize,
            iconAnchor: [iconSize[0] / 2, iconSize[1] / 2],
            popupAnchor: [0, -iconSize[1] / 2]
        });
    }

    function updateOwnMarker(lat, lon) {
        const latLng = [lat, lon];
        const icon = createMarkerIcon(currentUsername);

        if (ownMarker) {
            ownMarker.setLatLng(latLng);
            if (ownMarker.options.icon.options.className !== icon.options.className) {
                 ownMarker.setIcon(icon);
            }
        } else {
            ownMarker = L.marker(latLng, { icon: icon, zIndexOffset: 1000 }).addTo(map);
            ownMarker.bindPopup(`<strong>Das bin ich (${currentUsername})</strong>`);
        }
    }

    function updateMarker(username, lat, lon) {
        if (username === currentUsername) {
             updateOwnMarker(lat, lon);
             return;
        }

        const latLng = [lat, lon];
        const icon = createMarkerIcon(username);

        if (userMarkers[username]) {
            userMarkers[username].setLatLng(latLng);
             if (userMarkers[username].options.icon.options.className !== icon.options.className) {
                userMarkers[username].setIcon(icon);
             }
        } else {
            const zIndex = (username === mrXUsername) ? 900 : 500;
            userMarkers[username] = L.marker(latLng, { icon: icon, zIndexOffset: zIndex }).addTo(map);
            userMarkers[username].bindPopup(`<strong>${username}</strong> ${username === mrXUsername ? '<span style="color:red;">(Mr. X)</span>' : ''}`);
            console.log(`Marker für ${username} erstellt.`);
        }
    }

    function removeMarker(username) {
        if (userMarkers[username]) {
            map.removeLayer(userMarkers[username]);
            delete userMarkers[username];
            console.log(`Marker für ${username} entfernt.`);
        }
    }

    // --- Mr. X Aktionen ---
    function reportFound() {
        const finderSelect = document.getElementById('finder-selection');
        const selectedFinder = finderSelect ? finderSelect.value : null;

        if (!selectedFinder) {
            alert("Bitte wähle aus, wer dich gefunden hat.");
            return;
        }

        console.log(`Melde: Gefunden von ${selectedFinder}`);
        if (window.socket && window.socket.connected) {
            window.socket.emit('mr_x_found', { finder: selectedFinder });
            document.getElementById('found-button').disabled = true;
            finderSelect.disabled = true;
        } else {
            alert("Keine Verbindung zum Server. Konnte Fund nicht melden.");
        }
    }

    function toggleDecoyPlacement() {
        if (!isMrX || !mrxDecoyAvailable) return;
        isPlacingDecoy = !isPlacingDecoy;
        if (isPlacingDecoy) {
            enterDecoyPlacementMode();
        } else {
            exitDecoyPlacementMode();
        }
    }

    function enterDecoyPlacementMode() {
        console.log("Entering decoy placement mode.");
        isPlacingDecoy = true;
        document.getElementById('map').classList.add('decoy-placement-active');
        const decoyButton = document.getElementById('decoy-button');
        decoyButton.textContent = "Klicke auf die Karte für den falschen Standort...";
        decoyButton.classList.add('placing');
        showTemporaryMessage("Klicke auf die Karte, um den falschen Standort für das Ablenkungsmanöver zu wählen.", "info");
    }

    function exitDecoyPlacementMode() {
        console.log("Exiting decoy placement mode.");
        isPlacingDecoy = false;
        document.getElementById('map').classList.remove('decoy-placement-active');
        updateDecoyButtonState();
         if (tempDecoyMarker) {
            map.removeLayer(tempDecoyMarker);
            tempDecoyMarker = null;
        }
    }

    function handleMapClickForDecoy(e) {
        if (!isPlacingDecoy || !isMrX) return;

        const lat = e.latlng.lat;
        const lon = e.latlng.lng;
        console.log(`Decoy location selected: Lat=${lat}, Lon=${lon}`);

        if (tempDecoyMarker) map.removeLayer(tempDecoyMarker);
        tempDecoyMarker = L.marker([lat, lon], {
             icon: L.divIcon({ className: 'decoy-placement-marker', iconSize: [20, 20], iconAnchor: [10, 10] })
        }).addTo(map);
        tempDecoyMarker.bindPopup("Falscher Standort hier?").openPopup();

        if (window.socket && window.socket.connected) {
            window.socket.emit('set_decoy_location', { lat: lat, lon: lon });
        } else {
            alert("Keine Verbindung zum Server. Ablenkungsmanöver konnte nicht gesetzt werden.");
        }
        exitDecoyPlacementMode();
    }

    function updateDecoyButtonState() {
        const decoyButton = document.getElementById('decoy-button');
        if (!decoyButton) return;

        decoyButton.classList.remove('placing');
        if (mrxDecoyAvailable) {
            decoyButton.disabled = false;
            decoyButton.textContent = "Ablenkungsmanöver (1 verfügbar)";
        } else {
            decoyButton.disabled = true;
            decoyButton.textContent = "Ablenkungsmanöver benutzt";
        }
    }


    // --- Hilfsfunktionen für Finder-Liste ---
    function updateFinderList(playerUsernames) {
         const finderSelect = document.getElementById('finder-selection');
         if (!finderSelect) return;
         console.log("Updating finder list with players:", playerUsernames);
         const currentSelection = finderSelect.value;
         while (finderSelect.options.length > 1) {
             finderSelect.remove(1);
         }
         playerUsernames.forEach(username => {
             if (username !== currentUsername) {
                 const option = document.createElement('option');
                 option.value = username;
                 option.textContent = username;
                 finderSelect.appendChild(option);
             }
         });
         finderSelect.value = currentSelection;
     }

     function addPlayerToFinderList(username) {
         const finderSelect = document.getElementById('finder-selection');
         if (!finderSelect || username === currentUsername) return;
         console.log("Adding player to finder list:", username);
         let exists = false;
         for (let i = 0; i < finderSelect.options.length; i++) {
             if (finderSelect.options[i].value === username) {
                 exists = true;
                 break;
             }
         }
         if (!exists) {
             const option = document.createElement('option');
             option.value = username;
             option.textContent = username;
             finderSelect.appendChild(option);
         }
     }

     function removePlayerFromFinderList(username) {
         const finderSelect = document.getElementById('finder-selection');
         if (!finderSelect) return;
         console.log("Removing player from finder list:", username);
         for (let i = 0; i < finderSelect.options.length; i++) {
             if (finderSelect.options[i].value === username) {
                 finderSelect.remove(i);
                 break;
             }
         }
     }

     // --- Temporäre Nachrichten anzeigen ---
     function showTemporaryMessage(message, type = "info") {
         const messageDiv = document.createElement('div');
         messageDiv.textContent = message;
         messageDiv.style.position = 'absolute';
         messageDiv.style.top = '10px';
         messageDiv.style.left = '50%';
         messageDiv.style.transform = 'translateX(-50%)';
         messageDiv.style.padding = '10px 20px';
         messageDiv.style.borderRadius = '5px';
         messageDiv.style.zIndex = '1500';
         messageDiv.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
         messageDiv.style.opacity = '1';
         messageDiv.style.transition = 'opacity 0.5s ease-out';

         if (type === "error") {
             messageDiv.style.backgroundColor = '#f8d7da';
             messageDiv.style.color = '#721c24';
             messageDiv.style.border = '1px solid #f5c6cb';
         } else if (type === "warning") {
             messageDiv.style.backgroundColor = '#fcf8e3';
             messageDiv.style.color = '#8a6d3b';
             messageDiv.style.border = '1px solid #faebcc';
         } else { // info
             messageDiv.style.backgroundColor = '#d9edf7';
             messageDiv.style.color = '#31708f';
             messageDiv.style.border = '1px solid #bce8f1';
         }

         document.getElementById('map-container').appendChild(messageDiv);

         setTimeout(() => {
             messageDiv.style.opacity = '0';
             setTimeout(() => {
                 messageDiv.remove();
             }, 500);
         }, 3500);
     }

</script>

</body>
</html>
